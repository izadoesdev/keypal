module.exports=[83806,(a,b,c)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),Object.defineProperty(c,"registerServerReference",{enumerable:!0,get:function(){return d.registerServerReference}});let d=a.r(60770)},66680,(a,b,c)=>{b.exports=a.x("node:crypto",()=>require("node:crypto"))},3684,(a,b,c)=>{"use strict";function d(a){for(let b=0;b<a.length;b++){let c=a[b];if("function"!=typeof c)throw Object.defineProperty(Error(`A "use server" file can only export async functions, found ${typeof c}.
Read more: https://nextjs.org/docs/messages/invalid-use-server-value`),"__NEXT_ERROR_CODE",{value:"E352",enumerable:!1,configurable:!0})}}Object.defineProperty(c,"__esModule",{value:!0}),Object.defineProperty(c,"ensureServerEntryExports",{enumerable:!0,get:function(){return d}})},84733,a=>{"use strict";let b,c;var d=a.i(83806),e=a.i(66680);function f(a){!b||b.length<a?(b=Buffer.allocUnsafe(128*a),e.webcrypto.getRandomValues(b),c=0):c+a>b.length&&(e.webcrypto.getRandomValues(b),c=0),c+=a}function g(a){return f(a|=0),b.subarray(c-a,c)}function h(a,b=21){var c;let d,e;return c=b,e=Math.ceil(1.6*(d=(2<<31-Math.clz32(a.length-1|1))-1)*c/a.length),(b=c)=>{if(!b)return"";let f="";for(;;){let c=g(e),h=e;for(;h--;)if((f+=a[c[h]&d]||"").length>=b)return f}}}function i(a=21){f(a|=0);let d="";for(let e=c-a;e<c;e++)d+="useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict"[63&b[e]];return d}let j="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789",k=h(j,32);class l{keys=new Map;hashIndex=new Map;ownerIndex=new Map;logs=new Map;async save(a){if(this.keys.has(a.id))throw Error(`API key with id ${a.id} already exists`);if(this.hashIndex.has(a.keyHash))throw Error("API key hash collision detected");this.keys.set(a.id,a),this.hashIndex.set(a.keyHash,a.id);let{ownerId:b}=a.metadata;if(b){let c=this.ownerIndex.get(b)??new Set;c.add(a.id),this.ownerIndex.set(b,c)}}async findByHash(a){let b=this.hashIndex.get(a);return b?this.keys.get(b)??null:null}async findById(a){return this.keys.get(a)??null}async findByOwner(a){let b=this.ownerIndex.get(a);if(!b?.size)return[];let c=[];for(let a of b){let b=this.keys.get(a);b&&c.push(b)}return c}async findByTags(a,b){let c=a.map(a=>a.toLowerCase());return(void 0!==b?await this.findByOwner(b):Array.from(this.keys.values())).filter(a=>c.some(b=>a.metadata.tags?.includes(b)))}async findByTag(a,b){return this.findByTags([a],b)}async updateMetadata(a,b){let c=this.keys.get(a);if(!c)throw Error(`API key with id ${a} not found`);let d=c.metadata.ownerId;c.metadata={...c.metadata,...b};let e=c.metadata.ownerId;if(d!==e){if(d){let b=this.ownerIndex.get(d);b?.delete(a),b?.size===0&&this.ownerIndex.delete(d)}if(e){let b=this.ownerIndex.get(e)??new Set;b.add(a),this.ownerIndex.set(e,b)}}}async delete(a){let b=this.keys.get(a);if(b){this.hashIndex.delete(b.keyHash);let{ownerId:c}=b.metadata;if(c){let b=this.ownerIndex.get(c);b?.delete(a),b?.size===0&&this.ownerIndex.delete(c)}}this.keys.delete(a)}async deleteByOwner(a){let b=this.ownerIndex.get(a);if(b){for(let a of b){let b=this.keys.get(a);b&&(this.hashIndex.delete(b.keyHash),this.keys.delete(a))}this.ownerIndex.delete(a)}}saveLog(a){return this.logs.set(a.id,a),Promise.resolve()}findLogs(a){let b=Array.from(this.logs.values());a.keyId&&(b=b.filter(b=>b.keyId===a.keyId)),a.ownerId&&(b=b.filter(b=>b.ownerId===a.ownerId)),a.action&&(b=b.filter(b=>b.action===a.action)),a.startDate&&(b=b.filter(b=>b.timestamp>=a.startDate)),a.endDate&&(b=b.filter(b=>b.timestamp<=a.endDate)),b.sort((a,b)=>b.timestamp.localeCompare(a.timestamp));let c=a.offset??0,d=a.limit??100;return Promise.resolve(b.slice(c,c+d))}countLogs(a){let b=Array.from(this.logs.values());return a.keyId&&(b=b.filter(b=>b.keyId===a.keyId)),a.ownerId&&(b=b.filter(b=>b.ownerId===a.ownerId)),a.action&&(b=b.filter(b=>b.action===a.action)),a.startDate&&(b=b.filter(b=>b.timestamp>=a.startDate)),a.endDate&&(b=b.filter(b=>b.timestamp<=a.endDate)),Promise.resolve(b.length)}deleteLogs(a){let b=Array.from(this.logs.values());for(let c of(a.keyId&&(b=b.filter(b=>b.keyId===a.keyId)),a.ownerId&&(b=b.filter(b=>b.ownerId===a.ownerId)),a.action&&(b=b.filter(b=>b.action===a.action)),a.startDate&&(b=b.filter(b=>b.timestamp>=a.startDate)),a.endDate&&(b=b.filter(b=>b.timestamp<=a.endDate)),b))this.logs.delete(c.id);return Promise.resolve(b.length)}getLogStats(a){let b=Array.from(this.logs.values()).filter(b=>b.ownerId===a),c={},d=null;for(let a of b)c[a.action]=(c[a.action]||0)+1,(!d||a.timestamp>d)&&(d=a.timestamp);return Promise.resolve({total:b.length,byAction:c,lastActivity:d})}}async function m(a,b){let c=await a.exec();if(!c)throw Error(`Redis pipeline returned null for ${b}`);for(let a=0;a<c.length;a++){let d=c[a];if(d?.[0])throw Error(`Redis pipeline command ${a} failed in ${b}: ${d[0].message}`)}return c}function n(a){try{let b=JSON.parse(a);return"object"==typeof b&&null!==b&&"string"==typeof b.id&&"string"==typeof b.keyHash&&"object"==typeof b.metadata&&null!==b.metadata?b:null}catch{return null}}class o{redis;prefix;constructor(a){this.redis=a.client,this.prefix=a.prefix??"apikey:"}key(a){return`${this.prefix}${a}`}tagKey(a){return`${this.prefix}tag:${a}`}hashKey(a){return`${this.prefix}hash:${a}`}ownerKey(a){return`${this.prefix}owner:${a}`}async save(a){if(await this.findById(a.id))throw Error(`API key with id ${a.id} already exists`);let b=this.redis.pipeline();if(b.set(this.key(a.id),JSON.stringify(a)),b.set(this.hashKey(a.keyHash),a.id),b.sadd(this.ownerKey(a.metadata.ownerId),a.id),a.metadata.tags?.length)for(let c of a.metadata.tags)b.sadd(this.tagKey(c.toLowerCase()),a.id);await m(b,"save")}async findByHash(a){let b=await this.redis.get(this.hashKey(a));return b?this.findById(b):null}async findById(a){let b=await this.redis.get(this.key(a));return b?n(b):null}async findByOwner(a){let b=await this.redis.smembers(this.ownerKey(a));if(!b.length)return[];let c=this.redis.pipeline();for(let a of b)c.get(this.key(a));let d=await m(c,"findByOwner"),e=[];for(let a of d)if(a[1]){let b=n(a[1]);b&&e.push(b)}return e}async findByTags(a,b){let c=a.map(a=>this.tagKey(a.toLowerCase()));if(!c.length)return[];let d=1===c.length&&c[0]?await this.redis.smembers(c[0]):await this.redis.sunion(...c);if(void 0!==b&&d.length){let a=await this.redis.smembers(this.ownerKey(b));d=d.filter(b=>a.includes(b))}if(!d.length)return[];let e=this.redis.pipeline();for(let a of d)e.get(this.key(a));let f=await m(e,"findByTags"),g=[];for(let a of f)if(a[1]){let b=n(a[1]);b&&g.push(b)}return g}async findByTag(a,b){return this.findByTags([a],b)}async updateMetadata(a,b){let c=await this.findById(a);if(!c)throw Error(`API key with id ${a} not found`);let d=c.metadata.tags??[];c.metadata={...c.metadata,...b};let e=c.metadata.tags??[],f=this.redis.pipeline();if(f.set(this.key(a),JSON.stringify(c)),b.revokedAt&&f.del(this.hashKey(c.keyHash)),void 0!==b.tags){let b=new Set(d.map(a=>a.toLowerCase())),c=new Set(e.map(a=>a.toLowerCase()));for(let d of b)c.has(d)||f.srem(this.tagKey(d),a);for(let d of c)b.has(d)||f.sadd(this.tagKey(d),a)}await m(f,"updateMetadata")}async delete(a){let b=await this.findById(a);if(!b)return;let c=this.redis.pipeline();if(c.del(this.key(a)),c.del(this.hashKey(b.keyHash)),c.srem(this.ownerKey(b.metadata.ownerId),a),b.metadata.tags?.length)for(let d of b.metadata.tags)c.srem(this.tagKey(d.toLowerCase()),a);await m(c,"delete")}async deleteByOwner(a){let b=await this.redis.smembers(this.ownerKey(a));if(!b.length)return;let c=this.redis.pipeline();for(let a of b)c.get(this.key(a));let d=await m(c,"deleteByOwner:fetch"),e=this.redis.pipeline();for(let a=0;a<b.length;a++){let c=b[a];if(!c)continue;e.del(this.key(c));let f=d[a];if(f?.[1]){let a=n(f[1]);if(a&&(e.del(this.hashKey(a.keyHash)),a.metadata.tags?.length))for(let b of a.metadata.tags)e.srem(this.tagKey(b.toLowerCase()),c)}}e.del(this.ownerKey(a)),await m(e,"deleteByOwner:delete")}async setTtl(a,b){let c=await this.findById(a);if(!c)return;let d=this.redis.pipeline();d.expire(this.key(a),b),d.expire(this.hashKey(c.keyHash),b),await m(d,"setTtl")}}function p(a){return!!a&&new Date(a)<=new Date}let q=["authorization","x-api-key"];function r(a,b={}){let{headerNames:c=q,extractBearer:d=!0}=b;for(let b of c){let c=function(a,b){if(a instanceof Headers)return a.get(b);let c=b.toLowerCase();for(let b in a)if(b.toLowerCase()===c)return a[b]??null;return null}(a,b);if(!c)continue;let e=function(a,b){let c=a.trim();if(!c)return null;let d=c.toLowerCase();return"bearer"===d?null:d.startsWith("bearer ")&&b?c.slice(7).trim()||null:c}(c,d);if(e)return e}return null}class s{cache=new Map;maxSize;cleanupTimer=null;constructor(a={}){this.maxSize=a.maxSize??1e4;const b=a.cleanupInterval??6e4;this.cleanupTimer=setInterval(()=>this.cleanup(),b),this.cleanupTimer.unref?.()}get(a){let b=this.cache.get(a);return b?b.expires<Date.now()?(this.cache.delete(a),null):b.value:null}set(a,b,c=60){if(this.cache.size>=this.maxSize&&!this.cache.has(a)&&(this.cleanup(),this.cache.size>=this.maxSize)){let a=this.cache.keys().next().value;void 0!==a&&this.cache.delete(a)}this.cache.set(a,{value:b,expires:Date.now()+1e3*c})}del(a){this.cache.delete(a)}clear(){this.cache.clear()}cleanup(){let a=Date.now();for(let[b,c]of this.cache)c.expires<a&&this.cache.delete(b)}dispose(){this.cleanupTimer&&(clearInterval(this.cleanupTimer),this.cleanupTimer=null)}get size(){return this.cache.size}}class t{client;constructor(a){this.client=a}async get(a){return this.client.get(a)}async set(a,b,c=60){await this.client.setex(a,c,b)}async del(a){await this.client.del(a)}}function u(a,b={}){let{algorithm:c="sha256",salt:d=""}=b,f=d?`${a}${d}`:a;return(0,e.createHash)(c).update(f).digest("hex")}let v="MISSING_KEY",w="INVALID_FORMAT",x="INVALID_KEY",y="EXPIRED",z="REVOKED",A="DISABLED",B="ALREADY_REVOKED",C="ALREADY_ENABLED",D="ALREADY_DISABLED",E="CANNOT_MODIFY_REVOKED",F="KEY_NOT_FOUND",G="AUDIT_LOGGING_DISABLED",H="STORAGE_NOT_SUPPORTED",I={[v]:"Missing API key",[w]:"Invalid API key format",[x]:"Invalid API key",[y]:"API key has expired",[z]:"API key has been revoked",[A]:"API key is disabled",STORAGE_ERROR:"Storage error occurred",CACHE_ERROR:"Cache error occurred",[B]:"API key is already revoked",[C]:"API key is already enabled",[D]:"API key is already disabled",[E]:"Cannot modify a revoked key",[F]:"API key not found",[G]:"Audit logging is not enabled",[H]:"Storage does not support this operation"};function J(a,b){return{code:a,message:I[a],details:b}}function K(a,b){let c=J(a,b);return{valid:!1,error:c.message,errorCode:c.code}}let L=new class a{level;prefix;silent;constructor(a={}){this.level=a.level??"info",this.prefix=a.prefix??"",this.silent=a.silent??!1}shouldLog(a){if(this.silent)return!1;let b=["debug","info","warn","error"],c=b.indexOf(this.level);return b.indexOf(a)>=c}formatMessage(a,b){let c=this.prefix?`[${this.prefix}]`:"",d=a.toUpperCase();return`${c} ${d}: ${b}`}debug(a,...b){this.shouldLog("debug")&&console.debug(this.formatMessage("debug",a),...b)}info(a,...b){this.shouldLog("info")&&console.info(this.formatMessage("info",a),...b)}warn(a,...b){this.shouldLog("warn")&&console.warn(this.formatMessage("warn",a),...b)}error(a,...b){this.shouldLog("error")&&console.error(this.formatMessage("error",a),...b)}}({prefix:"keypal"});class M{config;storage;cache;cacheTtl;extractionOptions;revokedKeyTtl;isRedisStorage;autoTrackUsage;auditLogsEnabled;defaultContext;constructor(a={}){const b=a.salt?u(a.salt,{algorithm:"sha256"}):"";if(this.config={prefix:a.prefix,length:a.length??32,algorithm:a.algorithm??"sha256",alphabet:a.alphabet,salt:b},this.revokedKeyTtl=a.revokedKeyTtl??604800,this.isRedisStorage="redis"===a.storage,this.autoTrackUsage=a.autoTrackUsage??!0,this.auditLogsEnabled=a.auditLogs??!1,this.defaultContext=a.auditContext,"redis"===a.storage){if(!a.redis)throw Error('Redis client required when storage is "redis"');try{this.storage=new o({client:a.redis})}catch(a){throw L.error("CRITICAL: Failed to initialize Redis storage:",a),a}}else a.storage&&"object"==typeof a.storage?this.storage=a.storage:this.storage=new l;if(this.cacheTtl=a.cacheTtl??60,this.extractionOptions={headerNames:a.headerNames??["authorization","x-api-key"],extractBearer:a.extractBearer??!0},"redis"===a.cache){if(!a.redis)throw Error("[keypal] Redis client required when cache is 'redis'");try{this.cache=new t(a.redis)}catch(a){throw L.error("CRITICAL: Failed to initialize Redis cache:",a),a}}else!0===a.cache?this.cache=new s:a.cache&&"object"==typeof a.cache&&(this.cache=a.cache)}generateKey(){return function(a={}){let{prefix:b="",length:c=32,alphabet:d=j}=a,e=32===c&&d===j?k():h(d,c)();return b?`${b}${e}`:e}({prefix:this.config.prefix,length:this.config.length,alphabet:this.config.alphabet})}hashKey(a){return u(a,{algorithm:this.config.algorithm,salt:this.config.salt})}validateKey(a,b){return function(a,b,c={}){let d=u(a,c);return d.length===b.length&&(0,e.timingSafeEqual)(Buffer.from(d),Buffer.from(b))}(a,b,{algorithm:this.config.algorithm,salt:this.config.salt})}extractKey(a,b){return r(a,{headerNames:b?.headerNames??this.extractionOptions.headerNames,extractBearer:b?.extractBearer??this.extractionOptions.extractBearer})}hasKey(a,b){return function(a,b={}){return null!==r(a,b)}(a,{headerNames:b?.headerNames??this.extractionOptions.headerNames,extractBearer:b?.extractBearer??this.extractionOptions.extractBearer})}async verify(a,b={}){let c;if("string"==typeof a)c=a,a.startsWith("Bearer ")&&(c=a.slice(7).trim());else{let d={headerNames:b.headerNames??this.extractionOptions.headerNames,extractBearer:b.extractBearer??this.extractionOptions.extractBearer};c=this.extractKey(a,d)}if(!c)return K(v);if(this.config.prefix&&!c.startsWith(this.config.prefix))return K(w);let d=this.hashKey(c);if(this.cache&&!b.skipCache){let a=await this.cache.get(`apikey:${d}`);if(a)try{let c=JSON.parse(a);if("object"==typeof c&&null!==c&&"string"==typeof c.id&&(null===c.expiresAt||"string"==typeof c.expiresAt)&&(null===c.revokedAt||"string"==typeof c.revokedAt)&&"boolean"==typeof c.enabled){if(c.expiresAt&&p(c.expiresAt))return await this.cache.del(`apikey:${d}`),K(y);if(c.revokedAt)return await this.cache.del(`apikey:${d}`),K(z);if(!1===c.enabled)return K(A);let a=await this.storage.findById(c.id);return a?p(a.metadata.expiresAt)?(await this.cache.del(`apikey:${d}`),K(y)):a.metadata.revokedAt?(await this.cache.del(`apikey:${d}`),K(z)):(this.autoTrackUsage&&!b.skipTracking&&this.updateLastUsed(a.id).catch(a=>{L.error("Failed to track usage:",a)}),{valid:!0,record:a}):(await this.cache.del(`apikey:${d}`),K(x))}L.error("CRITICAL: Invalid cache record shape, invalidating entry"),await this.cache.del(`apikey:${d}`)}catch(a){L.error("CRITICAL: Cache corruption detected, invalidating entry:",a),await this.cache.del(`apikey:${d}`)}}let e=await this.storage.findByHash(d);if(!e)return K(x);if(p(e.metadata.expiresAt))return this.cache&&await this.cache.del(`apikey:${d}`),K(y);if(e.metadata.revokedAt)return this.cache&&await this.cache.del(`apikey:${d}`),K(z);if(!1===e.metadata.enabled)return K(A);if(this.cache&&!b.skipCache)try{let a={id:e.id,expiresAt:e.metadata.expiresAt??null,revokedAt:e.metadata.revokedAt??null,enabled:e.metadata.enabled??!0};await this.cache.set(`apikey:${d}`,JSON.stringify(a),this.cacheTtl)}catch(a){L.error("CRITICAL: Failed to write to cache:",a)}return this.autoTrackUsage&&!b.skipTracking&&this.updateLastUsed(e.id).catch(a=>{L.error("Failed to track usage:",a)}),{valid:!0,record:e}}async create(a,b){let c=this.generateKey(),d=this.hashKey(c),e=new Date().toISOString(),f=a.tags?.map(a=>a.toLowerCase()),g={id:i(),keyHash:d,metadata:{ownerId:a.ownerId??"",name:a.name,description:a.description,scopes:a.scopes,resources:a.resources,expiresAt:a.expiresAt??null,createdAt:e,lastUsedAt:void 0,enabled:a.enabled??!0,revokedAt:null,rotatedTo:null,tags:f}};return await this.storage.save(g),await this.logAction("created",g.id,g.metadata.ownerId,{...b,metadata:{name:g.metadata.name,scopes:g.metadata.scopes,...b?.metadata}}),{key:c,record:g}}async findByHash(a){return await this.storage.findByHash(a)}async findById(a){return await this.storage.findById(a)}async findByTags(a,b){return await this.storage.findByTags(a,b)}async findByTag(a,b){return await this.storage.findByTag(a,b)}async list(a){return await this.storage.findByOwner(a)}async revoke(a,b){let c=await this.findById(a);if(!c)throw J(F);if(c.metadata.revokedAt)throw J(B);if(await this.storage.updateMetadata(a,{revokedAt:new Date().toISOString()}),await this.logAction("revoked",a,c.metadata.ownerId,b),this.cache)try{await this.cache.del(`apikey:${c.keyHash}`)}catch(a){L.error("CRITICAL: Failed to invalidate cache on revoke:",a)}if(this.isRedisStorage&&this.revokedKeyTtl>0)try{this.storage instanceof o&&await this.storage.setTtl(a,this.revokedKeyTtl)}catch(a){L.error("Failed to set TTL on revoked key:",a)}}async revokeAll(a){let b=await this.list(a);await Promise.all(b.map(a=>this.revoke(a.id)))}async enable(a,b){let c=await this.findById(a);if(!c)throw J(F);if(c.metadata.revokedAt)throw J(E);if(c.metadata.enabled)throw J(C);if(await this.storage.updateMetadata(a,{enabled:!0}),await this.logAction("enabled",a,c.metadata.ownerId,b),this.cache)try{await this.cache.del(`apikey:${c.keyHash}`)}catch(a){L.error("CRITICAL: Failed to invalidate cache on enable:",a)}}async disable(a,b){let c=await this.findById(a);if(!c)throw J(F);if(c.metadata.revokedAt)throw J(E);if(!c.metadata.enabled)throw J(D);if(await this.storage.updateMetadata(a,{enabled:!1}),await this.logAction("disabled",a,c.metadata.ownerId,b),this.cache)try{await this.cache.del(`apikey:${c.keyHash}`)}catch(a){L.error("CRITICAL: Failed to invalidate cache on disable:",a)}}async rotate(a,b,c){let d=await this.findById(a);if(!d)throw J(F);if(d.metadata.revokedAt)throw J(E);let{key:e,record:f}=await this.create({ownerId:d.metadata.ownerId,name:b?.name??d.metadata.name,description:b?.description??d.metadata.description,scopes:b?.scopes??d.metadata.scopes,resources:b?.resources??d.metadata.resources,expiresAt:b?.expiresAt??d.metadata.expiresAt,tags:b?.tags?b.tags.map(a=>a.toLowerCase()):d.metadata.tags});if(await this.storage.updateMetadata(a,{rotatedTo:f.id,revokedAt:new Date().toISOString()}),await this.logAction("rotated",a,d.metadata.ownerId,{...c,metadata:{rotatedTo:f.id,...c?.metadata}}),this.cache)try{await this.cache.del(`apikey:${d.keyHash}`)}catch(a){L.error("CRITICAL: Failed to invalidate cache on rotate:",a)}if(this.isRedisStorage&&this.revokedKeyTtl>0)try{this.storage instanceof o&&await this.storage.setTtl(a,this.revokedKeyTtl)}catch(a){L.error("Failed to set TTL on rotated key:",a)}return{key:e,record:f,oldRecord:d}}async updateLastUsed(a){await this.storage.updateMetadata(a,{lastUsedAt:new Date().toISOString()})}async logAction(a,b,c,d){if(!(this.auditLogsEnabled&&this.storage.saveLog))return;let e={...this.defaultContext,...d,...this.defaultContext?.metadata||d?.metadata?{metadata:{...this.defaultContext?.metadata,...d?.metadata}}:{}},f={id:i(),action:a,keyId:b,ownerId:c,timestamp:new Date().toISOString(),data:Object.keys(e).length>0?e:void 0};try{await this.storage.saveLog(f)}catch(a){L.error("Failed to save audit log:",a)}}async getLogs(a={}){if(!this.auditLogsEnabled)throw J(G);if(!this.storage.findLogs)throw J(H);return await this.storage.findLogs(a)}async countLogs(a={}){if(!this.auditLogsEnabled)throw J(G);if(!this.storage.countLogs)throw J(H);return await this.storage.countLogs(a)}async deleteLogs(a){if(!this.auditLogsEnabled)throw J(G);if(!this.storage.deleteLogs)throw J(H);return await this.storage.deleteLogs(a)}async clearLogs(a){return await this.deleteLogs({keyId:a})}async getLogStats(a){if(!this.auditLogsEnabled)throw J(G);if(!this.storage.getLogStats)throw J(H);return await this.storage.getLogStats(a)}async invalidateCache(a){if(this.cache)try{await this.cache.del(`apikey:${a}`)}catch(a){throw L.error("CRITICAL: Failed to invalidate cache:",a),a}}isExpired(a){return p(a.metadata.expiresAt)}hasScope(a,b,c){var d,e;return d=a.metadata.scopes,e=a.metadata.resources,!!(d?.includes(b)||c?.resource&&e&&e[c.resource]?.includes(b))}hasAnyScope(a,b,c){return function(a,b,c,d){if(a&&c.some(b=>a.includes(b)))return!0;if(d?.resource&&b){let a=b[d.resource];if(a&&c.some(b=>a.includes(b)))return!0}return!1}(a.metadata.scopes,a.metadata.resources,b,c)}hasAllScopes(a,b,c){return function(a,b,c,d){if(a&&c.every(b=>a.includes(b)))return!0;if(d?.resource&&b){let e=b[d.resource];if(!e)return!1;if(c.every(a=>e.includes(a)))return!0;let f=[...a||[],...e];return c.every(a=>f.includes(a))}return!1}(a.metadata.scopes,a.metadata.resources,b,c)}async verifyFromHeaders(a,b){let c=await this.verify(a,b);return c.valid?c.record??null:null}checkResourceScope(a,b,c,d){return!!a&&this.hasScope(a,d,{resource:`${b}:${c}`})}checkResourceAnyScope(a,b,c,d){return!!a&&this.hasAnyScope(a,d,{resource:`${b}:${c}`})}checkResourceAllScopes(a,b,c,d){return!!a&&this.hasAllScopes(a,d,{resource:`${b}:${c}`})}}let N=function(a={}){return new M(a)}({prefix:"sk_mem_",storage:new l,cache:!0,cacheTtl:60,auditLogs:!0});async function O(a){try{let{key:b,record:c}=await N.create({ownerId:a.ownerId,name:a.name,scopes:a.scopes??["read"],resources:a.resources,expiresAt:a.expiresAt||null});return{success:!0,key:b,record:c}}catch(a){return{success:!1,error:String(a)}}}async function P(a){try{let b=await N.list(a);return{success:!0,keys:b}}catch(a){return{success:!1,error:String(a)}}}async function Q(a){try{return await N.verify(a)}catch(a){return{valid:!1,error:String(a)}}}async function R(a){try{return await N.revoke(a),{success:!0}}catch(a){return{success:!1,error:String(a)}}}async function S(a){try{return await N.enable(a),{success:!0}}catch(a){return{success:!1,error:String(a)}}}async function T(a){try{return await N.disable(a),{success:!0}}catch(a){return{success:!1,error:String(a)}}}async function U(a,b){try{let c=await N.getLogs({keyId:a,ownerId:b,limit:50});return{success:!0,logs:c}}catch(a){return{success:!1,error:String(a)}}}async function V(a){try{let b=await N.rotate(a);return{success:!0,...b}}catch(a){return{success:!1,error:String(a)}}}async function W(a,b,c){try{let d=await N.verify(a);if(!(d.valid&&d.record))return d;if(b&&b.length>0&&!N.hasAllScopes(d.record,b,c?{resource:c}:void 0))return{valid:!1,error:"Insufficient permissions",errorCode:"INSUFFICIENT_PERMISSIONS"};return d}catch(a){return{valid:!1,error:String(a)}}}(0,a.i(3684).ensureServerEntryExports)([O,P,Q,R,S,T,U,V,W]),(0,d.registerServerReference)(O,"408732526b0913eda4735601a76db162d32df5fe32",null),(0,d.registerServerReference)(P,"40434dc93db41af65e7dd89d0ae199b39810aa8010",null),(0,d.registerServerReference)(Q,"40ec5adf8ddb3c36d5f760992d5bbd19e37a53ff6d",null),(0,d.registerServerReference)(R,"4051a801f13e8e188c604b84e2fc63c1af815a0996",null),(0,d.registerServerReference)(S,"409d127c0868472cec5e54d503758f119da551b4d4",null),(0,d.registerServerReference)(T,"40e8f93476dd15da485b5ff2a12d60fd762c71ad85",null),(0,d.registerServerReference)(U,"60806188deb87fd6c48c5ae501633ab3be95ee8919",null),(0,d.registerServerReference)(V,"40a9d7c13b536f78b091282c2bb9aef4f0e1d1a1a7",null),(0,d.registerServerReference)(W,"7097902fa6daaa473361709b73c7e03e6687657cfb",null),a.s([],97189),a.i(97189),a.s(["40434dc93db41af65e7dd89d0ae199b39810aa8010",()=>P,"4051a801f13e8e188c604b84e2fc63c1af815a0996",()=>R,"408732526b0913eda4735601a76db162d32df5fe32",()=>O,"409d127c0868472cec5e54d503758f119da551b4d4",()=>S,"40a9d7c13b536f78b091282c2bb9aef4f0e1d1a1a7",()=>V,"40e8f93476dd15da485b5ff2a12d60fd762c71ad85",()=>T,"40ec5adf8ddb3c36d5f760992d5bbd19e37a53ff6d",()=>Q,"60806188deb87fd6c48c5ae501633ab3be95ee8919",()=>U,"7097902fa6daaa473361709b73c7e03e6687657cfb",()=>W],84733)}];

//# sourceMappingURL=%5Broot-of-the-server%5D__ac085190._.js.map